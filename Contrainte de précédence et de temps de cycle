#include <stdio.h>
#include <stdlib.h>

// Structure pour représenter une paire d'opérations
// structt
typedef struct {
    int op1;
    int op2;
} Precedence;

// Fonction pour vérifier les contraintes de précédence et de temps de cycle
int verifierContraintes(FILE *fichierPrecedences, FILE *fichierOperations, FILE *fichierTempsCycle, int nombreOperations) {
    // Lire le nombre d'arcs du graphe de précédence depuis le fichier
    int nombreArcs;
    fscanf(fichierPrecedences, "%d", &nombreArcs);

    // Créer une matrice d'adjacence pour représenter le graphe de précédence
    int **graphe = malloc(nombreOperations * sizeof(int *));
    for (int i = 0; i < nombreOperations; i++) {
        graphe[i] = malloc(nombreOperations * sizeof(int));
        for (int j = 0; j < nombreOperations; j++) {
            graphe[i][j] = 0;
        }
    }

    // Lire les arcs du graphe de précédence depuis le fichier
    Precedence *arcs = malloc(nombreArcs * sizeof(Precedence));
    for (int i = 0; i < nombreArcs; i++) {
        fscanf(fichierPrecedences, "%d %d", &arcs[i].op1, &arcs[i].op2);
        graphe[arcs[i].op1 - 1][arcs[i].op2 - 1] = 1; // Mettre à jour la matrice d'adjacence
    }

    // Vérifier les contraintes de précédence
    for (int i = 0; i < nombreArcs; i++) {
        if (!graphe[arcs[i].op1 - 1][arcs[i].op2 - 1]) {
            printf("Violation de la contrainte de précédence : Opération %d doit précéder Opération %d\n", arcs[i].op1, arcs[i].op2);
            return 1; // Indiquer une violation
        }
    }

    // Lire le temps de cycle depuis le fichier
    double tempsCycle;
    fscanf(fichierTempsCycle, "%lf", &tempsCycle);

    // Lire les temps d'exécution des opérations depuis le fichier
    double *tempsExecution = malloc(nombreOperations * sizeof(double));
    for (int i = 0; i < nombreOperations; i++) {
        int operation;
        double temps;
        fscanf(fichierOperations, "%d %lf", &operation, &temps);
        tempsExecution[operation - 1] = temps;
    }

    // Vérifier la contrainte de temps de cycle
    double tempsTotal = 0;
    for (int i = 0; i < nombreOperations; i++) {
        for (int j = 0; j < nombreOperations; j++) {
            if (graphe[i][j]) {
                tempsTotal += tempsExecution[j];
            }
        }
        if (tempsTotal > tempsCycle) {
            printf("Violation de la contrainte de temps de cycle à la station %d\n", i + 1);
            free(arcs);
            free(tempsExecution);
            return 1; // Indiquer une violation
        }
        tempsTotal = 0; // Réinitialiser le temps total pour la station suivante
    }
    printf("La contrainte de temps de cyle est respectee\n");


    // Libération de la mémoire
    free(arcs);
    free(tempsExecution);
    for (int i = 0; i < nombreOperations; i++) {
        free(graphe[i]);
    }
    free(graphe);

    return 0; // Aucune violation détectée
}

int main() {
    // Exemple d'utilisation
    FILE *fichierPrecedences = fopen("precedences.txt", "r");
    FILE *fichierOperations = fopen("operations.txt", "r");
    FILE *fichierTempsCycle = fopen("temps_cycle.txt", "r");

    if (fichierPrecedences == NULL || fichierOperations == NULL || fichierTempsCycle == NULL) {
        perror("Erreur lors de l'ouverture des fichiers");
        return EXIT_FAILURE;
    }

    // Nombre d'opérations (à adapter selon votre modèle)
    int nombreOperations = 35;

    int violation = verifierContraintes(fichierPrecedences, fichierOperations, fichierTempsCycle, nombreOperations);

    if (violation) {
        printf("Il y a des violations des contraintes.\n");
        exit(EXIT_FAILURE);
    } else {
        printf("Aucune violation des contraintes.\n");
    }

    fclose(fichierPrecedences);
    fclose(fichierOperations);
    fclose(fichierTempsCycle);
    return 0;
}

/*
# Fonction pour lire les opérations à partir du fichier
def lire_fichier_operations(chemin_fichier):
    operations = {}
    with open(chemin_fichier, 'r') as fichier:
        for ligne in fichier:
            ligne = ligne.strip().split()
            num_operation, temps_execution = int(ligne[0]), float(ligne[1])
            operations[num_operation] = temps_execution
    return operations

# Fonction pour lire les précédences à partir du fichier
def lire_fichier_precedences(chemin_fichier):
    precedences = []
    with open(chemin_fichier, 'r') as fichier:
        for ligne in fichier:
            ligne = ligne.strip().split()
            operation_precedente, operation_suivante = int(ligne[0]), int(ligne[1])
            precedences.append((operation_precedente, operation_suivante))
    return precedences

# Fonction pour lire le temps de cycle à partir du fichier
def lire_temps_cycle(chemin_fichier):
    with open(chemin_fichier, 'r') as fichier:
        temps_cycle = float(fichier.read().strip())
    return temps_cycle


# Fonction principale pour parcourir le graphe et vérifier le temps de cycle
def parcourir_graphe(operations, precedences, temps_cycle):
    for branche in precedences:
        temps_branche = 0
        for operation in branche:
            temps_branche += operations[operation]
            if temps_branche > temps_cycle:
                print(f"La branche {branche} dépasse le temps de cycle !")
                break
        else:
            print(f"La branche {branche} respecte le temps de cycle.")

# Point d'entrée du programme
if __name__ == "__main__":
    # Chemins des fichiers
    chemin_operations = "operations.txt"
    chemin_precedences = "precedences.txt"
    chemin_temps_cycle = "temps_cycle.txt"

    # Lecture des données à partir des fichiers
    operations = lire_fichier_operations(chemin_operations)
    precedences = lire_fichier_precedences(chemin_precedences)
    temps_cycle = lire_temps_cycle(chemin_temps_cycle)

    # Appel de la fonction principale
    parcourir_graphe(operations, precedences, temps_cycle)
*/

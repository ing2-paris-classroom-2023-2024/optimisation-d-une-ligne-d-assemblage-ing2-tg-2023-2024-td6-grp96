#include <stdio.h>
#include <stdlib.h>

// Structure pour représenter une paire d'opérations
// structt
typedef struct {
    int op1;
    int op2;
} Precedence;

// Fonction pour vérifier les contraintes de précédence et de temps de cycle
int verifierContraintes(FILE *fichierPrecedences, FILE *fichierOperations, FILE *fichierTempsCycle, int nombreOperations) {
    // Lire le nombre d'arcs du graphe de précédence depuis le fichier
    int nombreArcs;
    fscanf(fichierPrecedences, "%d", &nombreArcs);

    // Créer une matrice d'adjacence pour représenter le graphe de précédence
    int **graphe = malloc(nombreOperations * sizeof(int *));
    for (int i = 0; i < nombreOperations; i++) {
        graphe[i] = malloc(nombreOperations * sizeof(int));
        for (int j = 0; j < nombreOperations; j++) {
            graphe[i][j] = 0;
        }
    }

    // Lire les arcs du graphe de précédence depuis le fichier
    Precedence *arcs = malloc(nombreArcs * sizeof(Precedence));
    for (int i = 0; i < nombreArcs; i++) {
        fscanf(fichierPrecedences, "%d %d", &arcs[i].op1, &arcs[i].op2);
        graphe[arcs[i].op1 - 1][arcs[i].op2 - 1] = 1; // Mettre à jour la matrice d'adjacence
    }

    // Vérifier les contraintes de précédence
    for (int i = 0; i < nombreArcs; i++) {
        if (!graphe[arcs[i].op1 - 1][arcs[i].op2 - 1]) {
            printf("Violation de la contrainte de précédence : Opération %d doit précéder Opération %d\n", arcs[i].op1, arcs[i].op2);
            return 1; // Indiquer une violation
        }
    }

    // Lire le temps de cycle depuis le fichier
    double tempsCycle;
    fscanf(fichierTempsCycle, "%lf", &tempsCycle);

    // Lire les temps d'exécution des opérations depuis le fichier
    double *tempsExecution = malloc(nombreOperations * sizeof(double));
    for (int i = 0; i < nombreOperations; i++) {
        int operation;
        double temps;
        fscanf(fichierOperations, "%d %lf", &operation, &temps);
        tempsExecution[operation - 1] = temps;
    }

    // Vérifier la contrainte de temps de cycle
    double tempsTotal = 0;
    for (int i = 0; i < nombreOperations; i++) {
        for (int j = 0; j < nombreOperations; j++) {
            if (graphe[i][j]) {
                tempsTotal += tempsExecution[j];
            }
        }
        if (tempsTotal > tempsCycle) {
            printf("Violation de la contrainte de temps de cycle à la station %d\n", i + 1);
            free(arcs);
            free(tempsExecution);
            return 1; // Indiquer une violation
        }
        tempsTotal = 0; // Réinitialiser le temps total pour la station suivante
    }
    printf("La contrainte de temps de cyle est respectee\n");


    // Libération de la mémoire
    free(arcs);
    free(tempsExecution);
    for (int i = 0; i < nombreOperations; i++) {
        free(graphe[i]);
    }
    free(graphe);

    return 0; // Aucune violation détectée
}

int main() {
    // Exemple d'utilisation
    FILE *fichierPrecedences = fopen("precedences.txt", "r");
    FILE *fichierOperations = fopen("operations.txt", "r");
    FILE *fichierTempsCycle = fopen("temps_cycle.txt", "r");

    if (fichierPrecedences == NULL || fichierOperations == NULL || fichierTempsCycle == NULL) {
        perror("Erreur lors de l'ouverture des fichiers");
        return EXIT_FAILURE;
    }

    // Nombre d'opérations (à adapter selon votre modèle)
    int nombreOperations = 35;

    int violation = verifierContraintes(fichierPrecedences, fichierOperations, fichierTempsCycle, nombreOperations);

    if (violation) {
        printf("Il y a des violations des contraintes.\n");
        exit(EXIT_FAILURE);
    } else {
        printf("Aucune violation des contraintes.\n");
    }

    fclose(fichierPrecedences);
    fclose(fichierOperations);
    fclose(fichierTempsCycle);
    return 0;
}

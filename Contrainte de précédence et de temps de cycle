#include <stdio.h>
#include <stdlib.h>

typedef struct {
    int predecesseur;
    int operation;
} ContraintePrecedence;

typedef struct {
    ContraintePrecedence *contraintes;
    int nb_contraintes;
} LigneAssemblage;

typedef struct {
    int *operations;
    int nb_operations;
    int numStation;
    double tempsTotal;
} Station;

void lireContraintesDepuisFichier(const char *fichier, LigneAssemblage *ligne) {
    FILE *file = fopen(fichier, "r");
    if (file == NULL) {
        perror("Erreur lors de l'ouverture du fichier des contraintes de precedence");
        exit(EXIT_FAILURE);
    }

    int predecesseur, operation;
    int nb_contraintes = 0;

    while (fscanf(file, "%d %d", &predecesseur, &operation) == 2) {
        nb_contraintes++;
    }

    ligne->contraintes = malloc(nb_contraintes * sizeof(ContraintePrecedence));
    if (ligne->contraintes == NULL) {
        perror("Erreur lors de l'allocation mémoire pour les contraintes de précédence");
        exit(EXIT_FAILURE);
    }

    rewind(file);

    for (int i = 0; i < nb_contraintes; i++) {
        fscanf(file, "%d %d", &ligne->contraintes[i].predecesseur, &ligne->contraintes[i].operation);
    }

    ligne->nb_contraintes = nb_contraintes;

    fclose(file);
}

void lireTempsDepuisFichier(const char *fichier, double *temps, int taille) {
    FILE *file = fopen(fichier, "r");
    if (file == NULL) {
        perror("Erreur lors de l'ouverture du fichier des temps d'opérations");
        exit(EXIT_FAILURE);
    }

    int operation;
    double tempsOperation;

    while (fscanf(file, "%d %lf", &operation, &tempsOperation) == 2) {
        temps[operation] = tempsOperation;
    }

    fclose(file);
}

void lireTempsCycleDepuisFichier(const char *fichier, double *tempsCycle) {
    FILE *file = fopen(fichier, "r");
    if (file == NULL) {
        perror("Erreur lors de l'ouverture du fichier des temps de cycle");
        exit(EXIT_FAILURE);
    }

    fscanf(file, "%lf", tempsCycle);

    fclose(file);
}

Station* regrouperEnStations(LigneAssemblage *ligne) {
    int maxOperation = 0;
    int numStation = 1;

    for (int i = 0; i < ligne->nb_contraintes; i++) {
        if (ligne->contraintes[i].operation > maxOperation) {
            maxOperation = ligne->contraintes[i].operation;
        }
    }

    Station *stations = malloc((maxOperation + 1) * sizeof(Station));
    for (int i = 0; i <= maxOperation; i++) {
        stations[i].operations = NULL;
        stations[i].nb_operations = 0;
        stations[i].numStation = 0;
        stations[i].tempsTotal = 0.0;
    }

    for (int i = 0; i < ligne->nb_contraintes; i++) {
        int operationPredecesseur = ligne->contraintes[i].predecesseur;
        int operationActuelle = ligne->contraintes[i].operation;

        stations[operationPredecesseur].operations = realloc(stations[operationPredecesseur].operations,
                                                             (stations[operationPredecesseur].nb_operations + 1) * sizeof(int));
        stations[operationPredecesseur].operations[stations[operationPredecesseur].nb_operations] = operationActuelle;
        stations[operationPredecesseur].nb_operations++;

        if (stations[operationPredecesseur].numStation == 0) {
            stations[operationPredecesseur].numStation = numStation;
            numStation++;
        }
    }

    return stations;
}

void afficherTempsStations(Station *stations, int maxOperation) {
    double temps[100]; // Adapté à la taille de vos opérations
    for (int i = 0; i < 100; i++) {
        temps[i] = 0.0; // Initialisation des temps à zéro
    }
    for (int i = 1; i <= maxOperation; i++) {
        if (stations[i].numStation != 0) {
            double tempsTotalStation = 0.0;
            for (int j = 0; j < stations[i].nb_operations; j++) {
                tempsTotalStation += temps[stations[i].operations[j]];
            }
            stations[i].tempsTotal = tempsTotalStation;
            printf("Station %d - Temps total : %.2f\n", stations[i].numStation, stations[i].tempsTotal);
        }
    }
}

int main() {
    LigneAssemblage ligne;
    const char *fichierContraintes = "precedences.txt";
    const char *fichierTemps = "operations.txt";
    const char *fichierTempsCycle = "temps_cycle.txt";

    lireContraintesDepuisFichier(fichierContraintes, &ligne);

    double temps[100]; // Adapté à la taille de vos opérations
    for (int i = 0; i < 100; i++) {
        temps[i] = 0.0; // Initialisation des temps à zéro
    }
    lireTempsDepuisFichier(fichierTemps, temps, 100);

    Station *stations = regrouperEnStations(&ligne);

    double tempsCycle;
    lireTempsCycleDepuisFichier(fichierTempsCycle, &tempsCycle);

    int maxOperation = 0;
    for (int i = 0; i < ligne.nb_contraintes; i++) {
        if (ligne.contraintes[i].operation > maxOperation) {
            maxOperation = ligne.contraintes[i].operation;
        }
    }

    for (int i = 1; i <= maxOperation; i++) {
        double tempsTotalStation = 0.0;
        for (int j = 0; j < stations[i].nb_operations; j++) {
            tempsTotalStation += temps[stations[i].operations[j]];
        }
        stations[i].tempsTotal = tempsTotalStation;

        if (stations[i].tempsTotal > tempsCycle) {
            int nbStations = (int)(stations[i].tempsTotal / tempsCycle) + 1;
            double tempsTotalParStation = stations[i].tempsTotal / nbStations;

            free(stations[i].operations);

            stations[i].operations = malloc(stations[i].nb_operations * sizeof(int));
            if (stations[i].operations == NULL) {
                perror("Erreur lors de l'allocation mémoire pour les opérations d'une nouvelle station");
                exit(EXIT_FAILURE);
            }

            int k = 0;
            for (int s = 1; s <= nbStations; s++) {
                double tempsCourant = 0.0;
                while (tempsCourant < tempsTotalParStation && k < stations[i].nb_operations) {
                    tempsCourant += temps[stations[i].operations[k]];
                    k++;
                }
                stations[i].nb_operations = k;
            }
        }
    }

    afficherTempsStations(stations, maxOperation);

    free(ligne.contraintes);
    for (int i = 0; i <= maxOperation; i++) {
        free(stations[i].operations);
    }
    free(stations);

    return 0;
}
